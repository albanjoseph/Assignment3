\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{svg}
\usepackage{minted}
\usepackage{caption}
\usepackage{subcaption}
\setminted{fontsize=\footnotesize}
\lstset{frame=tb,   language=Python,   aboveskip=3mm,   belowskip=3mm,   showstringspaces=false,   columns=flexible,   basicstyle={\small\ttfamily},   numbers=none,   numberstyle=\tiny\color{gray},   keywordstyle=\color{blue},   commentstyle=\color{dkgreen},   stringstyle=\color{mauve},   breaklines=true,   breakatwhitespace=true,   tabsize=3 }

\title{Digital Signal Processing\\Assignment 3\\Fluid Pressure Sensing}
\author{2324362M - Connor MacLean\\2324421J - Alban Joseph}
\date{December 2020}

\begin{document}
\maketitle
Declaration of Originality and Submission Information.\\
I affirm that this submission is my own / the groups original work in accordance with the University of Glasgow Regulations and the School of Engineering Requirements.
\section{Introduction}
In various applications, it is desirable to monitor the pressure of a liquid in a tank. This can be done using a pressure sensor, however noise often needs to be removed, e.g.:
\begin{enumerate}
  \item Noise exists when monitoring the pressure of a fuel tank on a moving vehicle - the vibrations from driving would effect the signal measured. Hence, in order to determine the correct pressure, the signal could be passed through a filter to remove any noise.
  \item Industrial control systems often rely on accurate pressure measurements to monitor and optimise industrial processes. The process of adding or removing liquid from a tank can result in noise being introduced into the measurement system (movement of water causes changes in pressure). The raw signal from a pressure sensor will contain this noise on top of the low frequency signal we desire to measure. In industrial environments, accurate measurements of pressure often allows for the flow rate to be calculated and further adjustments to be made.
\begin{figure}[H]
    \centering
    \includesvg[scale=0.25]{figure1}
    \caption{Control System Data Flow Diagram}
    \label{fig:controlSys}
\end{figure}
To optimise the controllers response the high frequency noise must be removed from from our signal.
\end{enumerate}
In this experiment, we will take raw data from a pressure sensor and filter out any noise to achieve an accurate pressure reading. The experimental set up for real time data acquisition is displayed below in Figure \ref{fig:a}.
\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includesvg[scale=0.25]{figure3}
  \caption{}
  \label{fig:a}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=0.45]{pressureCircuit}
  \caption{}
  \label{fig:b}
\end{subfigure}
\caption{Experimental Set Up}
\label{fig:setUp}
\end{figure}
An Arduino Uno was used to sample data and the sensor was connected to the Arduino as shown in Figure \ref{fig:b}. The raw signal captured by the Arduino was sent into a python file to be filtered.
By disturbing the water and applying pressure to the outside of the tank we can mimic noise. A video detailing the experimental setup, and the results from the experiment, is available at...
 
\section{Sampling Rate Verification}
A class was created in the `timer.py' to check the sampling rate of the system:
\begin{lstlisting}
import time

class Timer:
    def __init__(self):
        self._start_time = None
        self.sampleCount = 0

    def start(self):
        #Start a new timer
        self._start_time = time.perf_counter()

    def reset(self):
        #Stop the timer, reset the counter, start the timer.
        self._start_time = None
        self.sampleCount = 0
        self._start_time = time.perf_counter()

    def time(self):
        #returns time elapsed
        elapsed_time = time.perf_counter() - self._start_time
        return elapsed_time
    
    def frequency(self):
        #determines frequency from time elapsed
        frequency = 1/(time.perf_counter() - self._start_time)
        return frequency
\end{lstlisting}
Several functions were created in this class for different purposes.
\begin{itemize}
  \item start(): starts a timer using the perf\_counter() function.
  \begin{itemize}
  \item perf\_counter() returns a value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration.
  \end{itemize}  
  \item reset(): stops the counter, resets all variables and starts a new timer again.
  \item time(): returns the time passed since the timer was started.
  \item frequency(): measures the time elapsed (since the timer started) and returns the frequency associated with this time interval.
\end{itemize}
The sampling rate of the acquisition was checked by running it for 10 seconds.\newline
The sampling rate should be 100Hz, so over 10 seconds, 1000 samples should be captured. In the main section of the code, a timer, `t', was started and the following code was placed in the `callBack' function (so it was executed every time the data was to be plotted):
\lstset{language=Python}
\begin{lstlisting}
t.sampleCount += 1 #increments number of samples counted
if t.time() >= 10: #if 10 seconds have passed
    print(t.sampleCount, ``= number of samples taken in 10 seconds'')
    t.reset() #resets the timer and sample count to 0
\end{lstlisting}
Objects of this timer class contain a variable used to count the number of samples captured - `sampleCount'. This variable is incremented every time a new data point is sampled. If 10 seconds have passed, then the number of samples captured is printed to the screen.
\newline
\begin{figure}[H]
    \centering
    \includesvg[scale=0.15]{rippleCounter}
    \caption{Sampling Rate over 10 seconds}
    \label{fig:tenSecs}
\end{figure}
\newline 
The code was run for slightly longer than one minute to improve the accuracy of the results. From Figure \ref{fig:tenSecs}, it is clear that a small inconsistency existed in the sampling: an extra one or two samples was being counted every ten seconds. This may be due to jitter. Jitter describes the timing errors in the sampling operation (often caused by clock disturbances). To identify jitter the above code was altered to the following:
\lstset{language=Python}
\begin{lstlisting}
print(t.frequency(), ``Hz'') #prints the sampling frequency
t.reset() #clock is reset
\end{lstlisting}
Every time data is captured a timer is reset. The frequency function measures the time between each sample and returns the frequency from this time interval, i.e. the sampling frequency.
\newline
\begin{figure}[H]
    \centering
    \includesvg[scale=0.25]{sampleFrequency}
    \caption{Sampling Rate between consecutive points}
    \label{fig:sampleF}
\end{figure}
\newline 
The sampling frequency varied from 80Hz to 120Hz, approximately . However, it was noted that occasionally the sampling frequency was measured to be over 5000Hz. This was considered to be jitter. Some heuristics could be put into place to ensure wrongly acquired data would not be plotted by:
\lstset{language=Python}
\begin{lstlisting}
def callBack(data):
    if t.frequency() < 1000: #if sampling frequency is less than 1000Hz
        #code for plotting data here
    t.reset() #resets timer
\end{lstlisting}
If the frequency measured between two consecutive points exceed 1000Hz then the data is not plotted. This was not included in our final implementation as 1 or 2 extra data points did not drastically effect the function of the system.

\section{Frequency Response}
Within the FIR Filter class a unit test was implemented to ensure the filter worked correctly. A simpler but less efficient method was implemented to calculate the expected output from the filter. The result from the inefficient method was compared to the doFilter, if the output was the same then test passed.

\lstset{language=Python}
\begin{lstlisting}
if __name__ ==``__main__'':
    unittest()
\end{lstlisting}
When the fir\_filter.py file is run, then the \_\_name\_\_ == ``\_\_main\_\_" condition is true. The unittest() function then is called.
Each array stores the coefficients for a specific 2nd order IIR filter. Another function is created which takes in a data value (x) and calls the filter defined in the class above.
\newline 
\lstset{language=Python}
\begin{lstlisting}
class IIRfilter: 
    def __init__(self, sos):
        self.filt = []
        for x in range(len(sos)):
            self.filt.append(IIR2filter(sos[x][0], sos[x][1], sos[x][2], sos[x][3], sos[x][4], sos[x][5]))
\end{lstlisting}
\newline
The SOS coefficients are generated by the high level function `signal.butter', It was found my trial and error that 1 was our ideal cut off frequency, providing the best response.
\newline
\lstset{language=Python}
\begin{lstlisting}
samplingRate = 100 #sampling rate: 100Hz
f1 = 1
sos = signal.butter(5,2*f1/samplingRate, output = 'sos') 
filt = IIR.IIRfilter(sos) 
\end{lstlisting}
\newline
\newline
The Discrete frequency normalised to Nyquist is given to the function. The sos coefficients returned are for 6 2nd order IIR filters. 


\section{Filter Class}


\subsection{2nd Order Filter}
The `IIR2filter' Class takes the SOS coefficients in as its constructor. These coefficients are stored as a0, a1, a2, b0, b1, b2 and two buffers are initialised; buffer1 and buffer2. within this class a filter function (filter) is implemented. This 2nd order IIR filter uses two accumulators; acc\_ input, and acc\_ output. An incoming data value is taken as the argument of the function. The IIR filter operation is outline below in both code and a data flow diagram.
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.25]{figure2}
    \caption{Direct Form II 2nd Order IIR Data Flow Diagram }
    \label{fig:universe}
\end{figure}
\newline 
This is a direct form II implementation as it uses two accumulators and two delay steps. The filtered value is then returned by the function. 
\newline
\newline
\begin{lstlisting}

    def filter(self, x): 
        acc_input = self.a0*x - self.buffer1*self.a1 - self.buffer2*self.a2 
        acc_output = acc_input*self.b0 + self.buffer1*self.b1 + self.buffer2*self.b2 
        self.buffer2 = self.buffer1
        self.buffer1 = acc_input
        return acc_output
\end{lstlisting}

\subsection{Chain of 2nd Order Filters}

Cascading second order IIR filters allows for the overall quality of the filtered signal to be improved whilst ensuring it remains relatively easy to design. A second class is defined which takes the sos coefficents from the Butterworth filter in its constructor. The coefficients are appended into a list of 6 arrays. 

The signal data is given to the 2nd order IIR filter function `filter'. The output data is then fed back into the filter function and the next lot of coefficients is call into the function. This repeats 6 times and the final value is output once it has been passed through each 2nd order IIR filter. 
\newline
\begin{lstlisting}
    def filter(self, x): 
        inP = x
        for i in range(len(self.filt)):
            outP = self.filt[i].filter(inP)
            inP = outP
        return outP
\end{lstlisting}
\newline
\newline
The Final piece of filtered data is stored in `outP' and returned by the function. 

\section{Results}
As can be seen in figure 6 the noise present in our signal has been completely removed from the sample by the low pass IIR filter. The filter signal follows the original signal reasonably well, however the low sampling rate of the Arduino limits the accuracy of sampling and therefore the resolution of the filter.  
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.13]{filterResults}
    \caption{Raw Data Vs Filtered Signal}
    \label{fig:universe}
\end{figure}
\newline 
Overall the filtering operation has been successful in removing the components of the signal above 1Hz. 
\bibliographystyle{plain}
\section{Appendix}
\subsection{IIR\_Filter.py}
\inputminted{python}{IIR_filter.py}
\subsection{timer.py}
\inputminted{python}{timer.py}
\subsection{realtimescope.py}
\inputminted{python}{realtimescope.py}
\subsection{realtime\_iir\_main.py}
\inputminted{python}{realtime_iir_main.py}
\end{document}