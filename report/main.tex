\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{svg}

\title{Digital Signal Processing Assignment 3}
\author{2324362M - Connor MacLean\\2324421J - Alban Joseph}
\date{December 2020}





\begin{document}
\maketitle
\section{Introduction}

In various industrial applications, it is desirable to monitor the rate of change of the volume of a liquid in a tank. The change of volume over time allows for the flow rate to be calculated and adjustments to be made by a controller. This can be done using a liquid pressure sensor. Often industrial control systems rely on accurate measurements to monitor and optimise industrial processes. The process of adding or removing liquid from the tank results in noise being introduced into our sensors signal. This introduces noise into the measurement system due to the movement of water and changes in pressure. The raw signal from a water pressure sensor will contain this noise on top of the low frequency changes in pressure we desire to measure. 
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.25]{figure1}
    \caption{Control System data flow diagram}
    \label{fig:universe}
\end{figure}
\newline 
For this assignment the concern lies with the sampling of the output. To optimise the controllers response the high frequency noise must be removed from from our signal. The experimental set up for real time data acquisition is displayed below in figure 2.
\newline
\begin{figure}[htbp]
  \centering
  \includesvg{image.svg}
  \caption{Experimental set up}
\end{figure}
\newline 

need to add Youtube video and photo of set up.
feel free to add anything else you like to this. 
I have made a data flow diagram but needs to be added in svg format. 









\section{Sampling Rate Verification}
A timer class was created to check the sampling rate of the system, timer.py:
\begin{lstlisting}[
    basicstyle=\small,
]
import time

class Timer:
    def __init__(self):
        self._start_time = None
        self.sampleCount = 0

    def start(self):
        #Start a new timer
        self._start_time = time.perf_counter()

    def reset(self):
        #Stop the timer, reset the counter, start the timer.
        self._start_time = None
        self.sampleCount = 0
        self._start_time = time.perf_counter()

    def time(self):
        #returns time elapsed
        elapsed_time = time.perf_counter() - self._start_time
        return elapsed_time
    
    def frequency(self):
        #determines frequency from time elapsed
        frequency = 1/(time.perf_counter() - self._start_time)
        return frequency
\end{lstlisting}
The timer makes use of the perf\_counter() function in the python library, `time'. Functions were created to start and reset the timer and also to return the time elapsed from the start time, and the frequency associated with that measured time interval.
In the main section of the code a timer `t' was instantiated. t.start() starts the timer:
\lstset{language=Python}
\begin{lstlisting}
t.sampleCount += 1
if t.time() >= 10: 
    print(t.sampleCount, "= number of samples taken in 10 seconds")
    t.reset() #resets the timer and sample count to 0
\end{lstlisting}
This code was placed in the `callBack' function, so it was executed every time the data was to be plotted. The sampling rate of the acquisition was checked by running it for 10 seconds. The following code was placed withing the function the filtered and plotted the data.\
Every time the data acquired is plotted the . If the timer has reached ten seconds then the number of data points acquired is printed to the screen.\\
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.15]{rippleCounter}
    \caption{Sampling Rate over 10 seconds}
    \label{fig:universe}
\end{figure}
\newline 
The code was run for slightly longer than one minute to improve consistency. It is clear There existed a small ripple, An extra one or two samples was being counted every ten seconds, this may be due to jitter. jitter describes the timing errors in the sampling operation caused by clock disturbances. To identify jitter the code was altered to the following The code above was altered to the following:
\lstset{language=Python}
\begin{lstlisting}
print(t.frequency(), ``Hz'') 
t.reset() 
\end{lstlisting}
The time was measured between each sample. Calculated the sampling frequency from this using the following formula:
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.25]{sampleFrequency}
    \caption{Sampling Rate over 10 seconds}
    \label{fig:universe}
\end{figure}
\newline 
The measured sampling frequency varied from approximately 80Hz to 120Hz. However, it was noted that occasionally the sampling frequency was measured to be over 5000Hz. This was obviouslyIf the sampling frequency was ... then this was considered jitter. Moving average +10PERCENT? Some heuristics could be put into place to ensure The wrongly acquired data would not be plotted by:
\lstset{language=Python}
\begin{lstlisting}
def callBack(data):
    if t.frequency() < 5000:
        #code for plotting data here
    t.reset() #resets timer
\end{lstlisting}
This was not included in our final implementation as 1 or 2 extra data points did not drastically effect the function of the system.







\section{Frequency Response}
Within the FIR Filter class a unit test was implemented to ensure the filter worked correctly. A simpler but less efficient method was implemented to calculate the expected output from the filter. The result from the inefficient method was compared to the doFilter, if the output was the same then test passed.

\lstset{language=Python}
\begin{lstlisting}
if __name__ ==``__main__'':
    unittest()
\end{lstlisting}
When the fir\_filter.py file is run, then the \_\_name\_\_ == ``\_\_main\_\_" condition is true. The unittest() function then is called.
Each array stores the coefficients for a specific 2nd order IIR filter. Another function is created which takes in a data value (x) and calls the filter defined in the class above.
\newline 
\lstset{language=Python}
\begin{lstlisting}
class IIRfilter: 
    def __init__(self, sos):
        self.filt = []
        for x in range(len(sos)):
            self.filt.append(IIR2filter(sos[x][0], sos[x][1], sos[x][2], sos[x][3], sos[x][4], sos[x][5]))
\end{lstlisting}
\newline
The SOS coefficients are generated by the high level function `signal.butter', It was found my trial and error that 1 was our ideal cut off frequency, providing the best response.
\newline
\lstset{language=Python}
\begin{lstlisting}
samplingRate = 100 #sampling rate: 100Hz
f1 = 1
sos = signal.butter(5,2*f1/samplingRate, output = 'sos') 
filt = IIR.IIRfilter(sos) 
\end{lstlisting}
\newline
\newline
The Discrete frequency normalised to Nyquist is given to the function. The sos coefficients returned are for 6 2nd order IIR filters. 



\section{Filter Class}
\subsection{2nd Order Filter}
The `IIR2filter' Class takes the SOS coefficients in as its constructor. These coefficients are stored as a0, a1, a2, b0, b1, b2 and two buffers are initialised; buffer1 and buffer2. within this class a filter function (filter) is implemented. This 2nd order IIR filter uses two accumulators; acc\_ input, and acc\_ output. An incoming data value is taken as the argument of the function. The IIR filter operation is outline below in both code and a data flow diagram.
\newline
\begin{figure}[h!]
    \centering
    \includesvg[scale=0.25]{figure2}
    \caption{Direct Form II 2nd Order IIR Data Flow Diagram }
    \label{fig:universe}
\end{figure}
\newline 
This is a direct form II implementation as it uses two accumulators and two delay steps. The filtered value is then returned by the function. 
\newline
\newline
\begin{lstlisting}

    def filter(self, x): 
        acc_input = self.a0*x - self.buffer1*self.a1 - self.buffer2*self.a2 
        acc_output = acc_input*self.b0 + self.buffer1*self.b1 + self.buffer2*self.b2 
        self.buffer2 = self.buffer1
        self.buffer1 = acc_input
        return acc_output
\end{lstlisting}

\subsection{Chain of 2nd Order Filters}

Cascading second order IIR filters allows for the overall quality of the filter to be improved whilst ensuring it remains relatively easy to design. A second class is defined which takes the sos coefficents from the Butterworth filter in its constructor. The coefficients are appended into a list of 6 arrays. 

The signal data is given to the 2nd order IIR filter function `filter'. The output data is then fed back into the filter function and the next lot of coefficients is call into the function. This repeats 6 times and the final value is output once it has been passed through each 2nd order IIR filter. 
\newline
\begin{lstlisting}
    def filter(self, x): 
        inP = x
        for i in range(len(self.filt)):
            outP = self.filt[i].filter(inP)
            inP = outP
        return outP
\end{lstlisting}
\newline
\newline
The Final piece of filtered data is stored in `outP' and returned by the function. 
\newline





\section{Results}
Compare your filtered results with the original recordings\\
have you been successful\\
Do a critical analysis

\bibliographystyle{plain}
\bibliography{references}
\end{document}